package OJ0311_0320;

import java.util.Arrays;
import java.util.PriorityQueue;

public class Super_Ugly_Number {
	/*
	 * https://discuss.leetcode.com/topic/34841/java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained
	 * 
	 * New ugly number is generated by multiplying a prime with previous generated 
	 * ugly number. One catch is need to remove duplicate.
	 * 
	 * Common solution from ugly number II , Theoretically O(kN)
	 * 
	 * Rf : 
	 * https://discuss.leetcode.com/topic/34841/java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained/4
	 * https://discuss.leetcode.com/topic/30999/108ms-easy-to-understand-java-solution
	 */
	public int nthSuperUglyNumber_I(int n, int[] primes) {
		int[] ugly = new int[n];
		int[] idx = new int[primes.length];

		ugly[0] = 1;
		for (int i = 1; i < n; i++) {
			// find next
			ugly[i] = primes[0] * ugly[idx[0]];
			for (int j = 0; j < primes.length; j++)
				ugly[i] = Math.min(ugly[i], primes[j] * ugly[idx[j]]);

			// slip duplicate
			for (int j = 0; j < primes.length; j++) {
				if (primes[j] * ugly[idx[j]] == ugly[i])
					idx[j]++;
			}
		}

		return ugly[n - 1];
	}
	
	/*
	 * https://discuss.leetcode.com/topic/34841/java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained
	 * 
	 * It has redundant multiplication can be avoided, 
	 * and also two for loops can be consolidated into one. 
	 * This trade-off space for speed. Theoretically O(kN)
	 */
	public int nthSuperUglyNumber_II(int n, int[] primes) {
		int[] ugly = new int[n];
		int[] idx = new int[primes.length];
		int[] val = new int[primes.length];
		Arrays.fill(val, 1);

		int next = 1;
		for (int i = 0; i < n; i++) {
			ugly[i] = next;

			next = Integer.MAX_VALUE;
			for (int j = 0; j < primes.length; j++) {
				// skip duplicate and avoid extra multiplication
				if (val[j] == ugly[i])
					val[j] = ugly[idx[j]++] * primes[j];
				// find next ugly number
				next = Math.min(next, val[j]);
			}
		}

		return ugly[n - 1];
	}
	
	/*
	 * The following class and function are from this link.
	 * https://discuss.leetcode.com/topic/34841/java-three-methods-23ms-36-ms-58ms-with-heap-performance-explained
	 * 
	 * By keep the one candidates for each prime in a heap, 
	 * it can improve the theoretical bound to O( log(k)N )
	 * 
	 * Rf : 
	 * https://discuss.leetcode.com/topic/31957/heap-is-slower-than-array-possible-explanation
	 * https://discuss.leetcode.com/topic/35149/java-31ms-o-nlgk-solution-with-heap
	 */
	public int nthSuperUglyNumberHeap(int n, int[] primes) {
		int[] ugly = new int[n];

		PriorityQueue<Num> pq = new PriorityQueue<>();
		for (int i = 0; i < primes.length; i++)
			pq.add(new Num(primes[i], 1, primes[i]));
		ugly[0] = 1;

		for (int i = 1; i < n; i++) {
			ugly[i] = pq.peek().val;
			while (pq.peek().val == ugly[i]) {
				Num nxt = pq.poll();
				pq.add(new Num(nxt.p * ugly[nxt.idx], nxt.idx + 1, nxt.p));
			}
		}

		return ugly[n - 1];
	}
	private class Num implements Comparable<Num> {
		int val;
		int idx;
		int p;

		public Num(int val, int idx, int p) {
			this.val = val;
			this.idx = idx;
			this.p = p;
		}

		@Override
		public int compareTo(Num that) {
			return this.val - that.val;
		}
	}

}
